package io.github.mikip98.ofg.automation.dot_properties_handlers;

import io.github.mikip98.ofg.automation.Util;
import net.fabricmc.loader.api.FabricLoader;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Stream;

import static io.github.mikip98.del.DataExtractionLibraryClient.LOGGER;

public class PropertiesWriter {

    public static void writeToProperties(
            Map<Short, Map<String, List<String>>> floodFillEmissiveBlockEntries,
            Map<Short, Map<String, List<String>>> floodFillEmissiveItemEntries,
            Map<Short, Map<String, List<String>>> floodFillTranslucentEntries,
            Map<Short, Map<String, List<String>>> floodFillIgnoreEntries
    ) {
        Path configPath = FabricLoader.getInstance().getGameDir().resolve("config/oasis-floodfill-generator");

        // Create the config directory if it doesn't exist
        try {
            Files.createDirectories(configPath);
        } catch (IOException e) {
            LOGGER.error("Error while creating config directory", e);
        }

        Set<String> ignoreFloodfillIds = new HashSet<>();
        for (int i = 0; i < Util.floodFillIgnoreEntryCount; i++) {
            ignoreFloodfillIds.add(String.valueOf(Util.floodFillIgnoreFirstEntryId + i));
        }
        Set<Character> numbers = new HashSet<>(Arrays.asList('0', '1', '2', '3', '4', '5', '6', '7', '8', '9'));

        try (Stream<Path> paths = Files.list(configPath)) {
            paths.filter(file -> file.toString().endsWith(".properties")).forEach(propertiesPath -> {
                // Write the properties file
                StringBuilder new_properties = new StringBuilder();

                try(BufferedReader br = new BufferedReader(new FileReader(propertiesPath.toString()))) {
                    String line;
                    short entryId = Util.floodFillIgnoreFirstEntryId;
                    boolean isEntryFloodfillIgnore = false;
                    while ((line = br.readLine()) != null) {
                        if (
                                line.strip().length() > 6 + String.valueOf(Util.floodFillIgnoreFirstEntryId).length()
                                && ignoreFloodfillIds.contains(line.strip().substring(6, 6 + String.valueOf(Util.floodFillIgnoreFirstEntryId).length()))
                                && !numbers.contains(line.strip().charAt(6 + String.valueOf(Util.floodFillIgnoreFirstEntryId).length()))
                        ) isEntryFloodfillIgnore = true;

                        new_properties.append(line);

                        if (isEntryFloodfillIgnore && !line.strip().endsWith("\\")) {
                            new_properties.append(" \\\n");
                            new_properties.append(" #ifdef AUTO_GENERATED_FLOODFILL\n");

                            new_properties.append(' ').append(prepareMessage(floodFillIgnoreEntries.get(entryId)));

                            new_properties.append("\n #endif");
                            entryId++;
                            isEntryFloodfillIgnore = false;
                        }

                        new_properties.append("\n");
                    }
                } catch (IOException e) {
                    LOGGER.error("Error while reading properties file", e);
                }

                new_properties.append("\n\n\n# Auto Floodfill generated by 'Oasis FloodFill Generator'\n");
                new_properties.append("#ifdef AUTO_GENERATED_FLOODFILL\n");
                List<Short> entryIds;

                new_properties.append("\n# Emissive Format 1 Block\n");
                entryIds = new ArrayList<>(floodFillEmissiveBlockEntries.keySet());
                Collections.sort(entryIds);
                for (Short entryId : entryIds) {
                    new_properties
                            .append("block.").append(entryId).append(" = ")
                            .append(prepareMessage(floodFillEmissiveBlockEntries.get(entryId)))
                            .append("\n");
                }

                new_properties.append("\n# Translucent\n");
                entryIds = new ArrayList<>(floodFillTranslucentEntries.keySet());
                Collections.sort(entryIds);
                for (Short entryId : entryIds) {
                    new_properties
                            .append("block.").append(entryId)
                            .append(" = ")
                            .append(prepareMessage(floodFillTranslucentEntries.get(entryId)))
                            .append("\n");
                }

                new_properties.append("\n#endif\n");

//                new_properties.append("\n# Ignored by Floodfill\n");
//                entryIds = new ArrayList<>(floodFillIgnoreEntries.keySet());
//                Collections.sort(entryIds);
//                for (Short entryId : entryIds) {
//                    new_properties
//                            .append("block.").append(entryId)
//                            .append(" = ")
//                            .append(prepareMessage(floodFillIgnoreEntries.get(entryId)))
//                            .append("\n");
//                }

                try {
                    Files.write(propertiesPath, new_properties.toString().getBytes());
                } catch (IOException e) {
                    LOGGER.error("Error while writing properties file", e);
                }
            });
        } catch (IOException e) {
            LOGGER.error("Error while writing properties file", e);
        }
    }
    public static String prepareMessage(Map<String, List<String>> floodFillIgnoreEntry) {
        StringBuilder stringBuilder = new StringBuilder();

        List<String> modIds = new ArrayList<>(floodFillIgnoreEntry.keySet());
        Collections.sort(modIds);

        for (String modId : modIds) {
            List<String> blockstateIds = floodFillIgnoreEntry.get(modId);
            stringBuilder.append(String.join(" ", blockstateIds.stream().map(blockstateId -> modId + ":" + blockstateId).toList())).append(" \\\n ");
        }

        return stringBuilder.delete(stringBuilder.length() - 4, stringBuilder.length()).toString();
    }
}
